<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>Arithmetic Instructions</title>
</head>
<body><h1 id='arithmetic-instructions'>Arithmetic Instructions</h1>
<p>Let&#39;s explore some arithmetic instructions.</p>
<h2 id='the-incdec-instruction'>The INC/DEC instruction</h2>
<p>The INC instruction is used for incrementing an operand by one. It works on a single operand that can be either in a register or in memory. The DEC instruction is used for decrementing an operand by one.</p>
<pre><code class='language-assembly' lang='assembly'>section .text
    global _start

_start:
    mov eax,10
    inc eax
  
    mov eax,1
    int 0x80
</code></pre>
<p>The above code is dissected using the <code>gdb</code> application. See the value of the eax register. The decimal value is 11, and the corresponding hex value is 0xb.</p>
<p><img width="1003" alt="image" src="https://user-images.githubusercontent.com/11669149/223891859-55ce3503-c862-4b08-ad99-7944fea82d4c.png"></p>
<h2 id='the-add-and-sub-instructions'>The ADD and SUB Instructions</h2>
<p>The ADD and SUB instructions are used for performing simple addition/subtraction of binary data in byte, word, and doubleword size, i.e., for adding or subtracting 8-bit, 16-bit, or 32-bit operands, respectively.</p>
<p>The ADD/SUB instruction can take place between</p>
<ul>
<li>Register to register</li>
<li>Memory to register</li>
<li>Register to memory</li>
<li>Register to constant data</li>
<li>Memory to constant data</li>

</ul>
<p>However, like other instructions, memory-to-memory operations are not possible using ADD/SUB instructions. An ADD or SUB operation sets or clears the overflow and carry flags.</p>
<p>The following example will ask for two digits from the user, store the digits in the EAX and EBX register, add the values, store the result in a memory location &#39;res&#39;, and finally display the result.</p>
<pre><code class='language-assembly' lang='assembly'>SYS_EXIT  equ 1
SYS_READ  equ 3
SYS_WRITE equ 4
STDIN     equ 0
STDOUT    equ 1

segment .data 

   msg1 db &quot;Enter a digit &quot;, 0xA,0xD 
   len1 equ $- msg1 

   msg2 db &quot;Please enter a second digit&quot;, 0xA,0xD 
   len2 equ $- msg2 

   msg3 db &quot;The sum is: &quot;
   len3 equ $- msg3

segment .bss

   num1 resb 2 
   num2 resb 2 
   res resb 1    

section	.text
   global _start    ;must be declared for using gcc
	
_start:             ;tell linker entry point
   mov eax, SYS_WRITE         
   mov ebx, STDOUT         
   mov ecx, msg1         
   mov edx, len1 
   int 0x80                

   mov eax, SYS_READ 
   mov ebx, STDIN  
   mov ecx, num1 
   mov edx, 2
   int 0x80            

   mov eax, SYS_WRITE        
   mov ebx, STDOUT         
   mov ecx, msg2          
   mov edx, len2         
   int 0x80

   mov eax, SYS_READ  
   mov ebx, STDIN  
   mov ecx, num2 
   mov edx, 2
   int 0x80        

   mov eax, SYS_WRITE         
   mov ebx, STDOUT         
   mov ecx, msg3          
   mov edx, len3         
   int 0x80

   ; moving the first number to eax register and second number to ebx
   ; and subtracting ascii &#39;0&#39; to convert it into a decimal number
	
   mov eax, [num1]
   sub eax, &#39;0&#39;
	
   mov ebx, [num2]
   sub ebx, &#39;0&#39;

   ; add eax and ebx
   add eax, ebx
   ; add &#39;0&#39; to convert the sum from decimal to ASCII
   add eax, &#39;0&#39;

   ; storing the sum in memory location res
   mov [res], eax

   ; print the sum 
   mov eax, SYS_WRITE        
   mov ebx, STDOUT
   mov ecx, res         
   mov edx, 1        
   int 0x80

exit:    
   
   mov eax, SYS_EXIT   
   xor ebx, ebx 
   int 0x80
</code></pre>
<blockquote><p><strong>segment .bss</strong> An assembly language code that contains statically allocated variables that are declared but have not been assigned a value yet. It is often called the &quot;bss section&quot; or &quot;bss segment&quot;.</p>
</blockquote>
<h2 id='the-mulimul-instruction'>The MUL/IMUL instruction</h2>
<p>There are two instructions for multiplying binary data. The MUL (Multiply) instruction handles unsigned data and the IMUL (Integer Multiply) handles signed data. Both instructions affect the Carry and Overflow flag.</p>
<blockquote><p><strong>Depending upon the size of the multiplicand, the multiplier, and the generated product, the product is either stored in one register or two registers depending upon the size of the operands.</strong></p>
</blockquote>
<p><strong>When two bytes are multiplied, the multiplicand is in the AL register, and the multiplier is a byte in the memory or another register.</strong> The product is in the eax register, as shown in the debugger&#39;s output. However, this is not a restriction, and any size of the register can be used for operands. For efficiency purposes, I used AL and DL registers. The distinction between registers is shown in the figure below.</p>
<pre><code class='language-assembly' lang='assembly'>section .text
		global _start
		
_start:
		mov al,10
		mov dl,25
		mul dl
		
		mov eax,1
		int 0x80
```
</code></pre>
<p>&nbsp;</p>
<p><img width="1250" alt="image" src="https://user-images.githubusercontent.com/11669149/223907405-4e765993-af50-469f-a77b-88b995a6f05d.png"></p>
<blockquote><p><strong>When referring to registers in assembly language, the names are not case-sensitive. For example, the names <code>EAX</code> and <code>eax</code> refer to the same register.</strong></p>
</blockquote>
<p>The following figure shows the <strong>x86 Registers</strong>.</p>
<p><img width="694" alt="image" src="https://user-images.githubusercontent.com/11669149/223949886-b2796233-aa52-4656-986d-0d0e77f32cba.png"></p>
<h2 id='the-dividiv-instruction'>The DIV/IDIV instruction</h2>
<p>The division operation generates two elements - a quotient and a remainder. In case of multiplication, overflow does not occur because double-length registers are used to keep the product. However, in case of division, overflow may occur. The processor generates an interrupt if overflow occurs.</p>
<p>The DIV (Divide) instruction is used for unsigned data and the IDIV (Integer Divide) is used for signed data.</p>
<p>The following example divides 8 with 2. The dividend 8 is stored in the 16-bit AX register and the divisor 2 is stored in the 8-bit BL register.</p>
<pre><code class='language-assembly' lang='assembly'>section .text
	global _start

_start:
	mov ax,8
	mov bl,2
	div bl
	
	mov eax,1
	int 0x80
</code></pre>
<p>When the divisor is 1 byte âˆ’</p>
<p>The dividend is assumed to be in the AX register (16 bits). After division, the quotient goes to the AL register and the remainder goes to the AH register.</p>
<p><img width="402" alt="image" src="https://user-images.githubusercontent.com/11669149/223963271-09306344-30f1-4859-bbb0-e7c76e71a8b6.png"></p>
<p>The following debugged code shows the process of division (8/2), the AL register (quotient) value is 4 and the AH register (remainder) is 0.</p>
<p><img width="795" alt="image" src="https://user-images.githubusercontent.com/11669149/223955017-7736aa43-8407-47ac-84de-cfcfb0df7fe6.png"></p>
</body>
</html>